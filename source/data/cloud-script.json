{
    "Version": 1,
    "Revision": 5,
    "CreatedAt": "2019-08-08T21:49:56.738Z",
    "Files": [
        {
            "Filename": "main.js",
            "FileContents": "\"use strict\";\nconst App = {\n    IsNull(data) {\n        return typeof data === \"undefined\"\n            || data === null\n            || (typeof data === \"string\" && data.length === 0)\n            || (data.constructor === Array && data.length === 0);\n    },\n    GetTitleData(keys, isJSON) {\n        const data = server.GetTitleData({\n            Keys: keys\n        }).Data;\n        if (!isJSON) {\n            return data;\n        }\n        return Object.keys(data).reduce((dictionary, key) => {\n            dictionary[key] = JSON.parse(data[key]);\n            return dictionary;\n        }, {});\n    },\n    EvaluateRandomResultTable(catalogVersion, tableId) {\n        return server.EvaluateRandomResultTable({\n            CatalogVersion: catalogVersion,\n            TableId: tableId\n        }).ResultItemId;\n    },\n    GetPlayerStatistics(playerId, statisticNames) {\n        return server.GetPlayerStatistics({\n            PlayFabId: playerId,\n            StatisticNames: statisticNames,\n        }).Statistics;\n    },\n    UpdatePlayerStatistics(playerId, statistics) {\n        return server.UpdatePlayerStatistics({\n            PlayFabId: playerId,\n            Statistics: statistics,\n        });\n    },\n    ConsumeItem(playerId, itemInstanceId, count) {\n        return server.ConsumeItem({\n            PlayFabId: playerId,\n            ItemInstanceId: itemInstanceId,\n            ConsumeCount: count\n        });\n    },\n    GrantItemsToUser(playerId, itemIds, catalogVersion = null) {\n        const grantResult = server.GrantItemsToUser({\n            PlayFabId: playerId,\n            ItemIds: itemIds,\n            CatalogVersion: catalogVersion\n        });\n        // Is this a bundle of something we need to unpack?\n        grantResult.ItemGrantResults.forEach(item => {\n            if (!App.IsNull(item.ItemClass) && item.ItemClass.indexOf(App.CatalogItems.UnpackClassName) !== -1) {\n                App.ConsumeItem(playerId, item.ItemInstanceId, item.RemainingUses);\n            }\n        });\n    },\n    GetUserInventory(playerId) {\n        return server.GetUserInventory({\n            PlayFabId: playerId,\n        });\n    },\n    GetUserData(playerId, keys) {\n        return server.GetUserData({\n            PlayFabId: playerId,\n            Keys: keys,\n        });\n    },\n    GetUserInternalData(playerId, keys) {\n        return server.GetUserInternalData({\n            PlayFabId: playerId,\n            Keys: keys,\n        });\n    },\n    UpdateUserData(playerId, data, keysToRemove, isPublic = false) {\n        return server.UpdateUserData({\n            PlayFabId: playerId,\n            Data: data,\n            KeysToRemove: keysToRemove,\n            Permission: isPublic\n                ? App.Config.PermissionPublic\n                : App.Config.PermissionPrivate\n        });\n    },\n    UpdateUserInternalData(playerId, data, keysToRemove, isPublic = false) {\n        return server.UpdateUserInternalData({\n            PlayFabId: playerId,\n            Data: data,\n            KeysToRemove: keysToRemove,\n            Permission: isPublic\n                ? App.Config.PermissionPublic\n                : App.Config.PermissionPrivate\n        });\n    },\n    WritePlayerEvent(playerId, eventName, body) {\n        // Event name only allows characters and underscores\n        eventName = eventName.replace(/[^a-z_]/gi, \"_\");\n        if (eventName.length > 64) {\n            eventName = eventName.substr(0, 64);\n        }\n        server.WritePlayerEvent({\n            PlayFabId: playerId,\n            EventName: eventName,\n            Body: body,\n        });\n    },\n    Statistics: {\n        Kills: \"kills\",\n        Level: \"level\",\n        XP: \"xp\"\n    },\n    TitleData: {\n        Planets: \"Planets\",\n        Enemies: \"Enemies\",\n        Levels: \"Levels\",\n    },\n    UserData: {\n        HP: \"hp\",\n        MaxHP: \"maxHP\",\n        Equipment: \"equipment\"\n    },\n    CatalogItems: {\n        UnpackClassName: \"unpack\",\n    },\n    VirtualCurrency: {\n        Credits: \"CR\"\n    },\n    Config: {\n        StartingHP: 100,\n        StartingLevel: 1,\n        StartingXP: 0,\n        PermissionPublic: \"Public\",\n        PermissionPrivate: \"Private\"\n    }\n};\n/*\n    This function:\n        1. Ensures the user isn't cheating by validating the monsters and location\n        2. Updates kills statistic\n        3. Updates XP statistic\n        4. If appropriate, updates level, which includes:\n            4a. Increased max HP\n            4b. Item granted\n            4c. Set current HP to max HP\n        5. Updates new HP user data\n        6. If this enemy group has a droptable, grant the user that item\n*/\nhandlers.killedEnemyGroup = function (args, context) {\n    // Retrieve all the data we'll need to make these updates\n    const titleData = App.GetTitleData([App.TitleData.Planets, App.TitleData.Enemies, App.TitleData.Levels], true);\n    const planetData = titleData[App.TitleData.Planets].planets;\n    const enemyData = titleData[App.TitleData.Enemies];\n    const userData = App.GetUserInternalData(currentPlayerId, [App.UserData.MaxHP]).Data;\n    const statistics = App.GetPlayerStatistics(currentPlayerId, [App.Statistics.Kills, App.Statistics.XP, App.Statistics.Level]);\n    // STEP 1: Ensure the data submitted is valid\n    const errorMessage = isKilledEnemyGroupValid(args, planetData, enemyData);\n    if (!App.IsNull(errorMessage)) {\n        return {\n            errorMessage,\n        };\n    }\n    // Data is valid, continue\n    const fullEnemyGroup = enemyData.enemyGroups.find(e => e.name === args.enemyGroup);\n    // Update player statistics and user data\n    const itemsGranted = [];\n    const statisticUpdates = [];\n    const userDataUpdates = {};\n    const response = {};\n    // STEP 2: Update number of kills\n    const killStatistic = statistics.find(s => s.StatisticName === App.Statistics.Kills);\n    const startingKills = App.IsNull(killStatistic)\n        ? 0\n        : killStatistic.Value;\n    const newKills = startingKills + fullEnemyGroup.enemies.length;\n    response.kills = newKills;\n    statisticUpdates.push({\n        StatisticName: App.Statistics.Kills,\n        Value: newKills,\n    });\n    // STEP 3: How much XP you earned from that enemy group\n    const xpStatistic = statistics.find(s => s.StatisticName === App.Statistics.XP);\n    const startingXP = App.IsNull(xpStatistic)\n        ? App.Config.StartingXP\n        : xpStatistic.Value;\n    const yourXP = fullEnemyGroup.enemies\n        .map(e => enemyData.enemies.find(e2 => e2.name === e).xp)\n        .reduce((totalXP, enemyXP) => {\n        return totalXP + enemyXP;\n    }, startingXP);\n    response.xp = yourXP;\n    statisticUpdates.push({\n        StatisticName: App.Statistics.XP,\n        Value: yourXP,\n    });\n    // STEP 4: Did you gain a level?\n    let newMaxHP = App.IsNull(userData[App.UserData.MaxHP])\n        ? App.Config.StartingHP\n        : parseInt(userData[App.UserData.MaxHP].Value);\n    const levelStatistic = statistics.find(s => s.StatisticName === App.Statistics.Level);\n    let originalLevelNumber = App.IsNull(levelStatistic)\n        ? App.Config.StartingLevel\n        : levelStatistic.Value;\n    let yourLevelNumber = originalLevelNumber;\n    // Allow the user to go up multiple levels simultaneously (somehow)\n    let newLevel = levelPlayer(titleData[App.TitleData.Levels], yourLevelNumber, yourXP);\n    while (!App.IsNull(newLevel)) {\n        // Grant the user a new level and all the perks and privileges that come from it\n        yourLevelNumber = newLevel.level;\n        if (!App.IsNull(newLevel.itemGranted)) {\n            itemsGranted.push(newLevel.itemGranted);\n        }\n        // HP goes up\n        newMaxHP += newLevel.hpGranted;\n        newLevel = levelPlayer(titleData[App.TitleData.Levels], yourLevelNumber, yourXP);\n    }\n    if (yourLevelNumber !== originalLevelNumber) {\n        statisticUpdates.push({\n            StatisticName: App.Statistics.Level,\n            Value: yourLevelNumber\n        });\n        response.level = yourLevelNumber;\n        userDataUpdates[App.UserData.MaxHP] = newMaxHP.toString();\n        userDataUpdates[App.UserData.HP] = newMaxHP.toString();\n        response.hp = newMaxHP;\n    }\n    else {\n        userDataUpdates[App.UserData.HP] = args.playerHP.toString();\n    }\n    // STEP 5: Do both updates\n    App.UpdatePlayerStatistics(currentPlayerId, statisticUpdates);\n    App.UpdateUserInternalData(currentPlayerId, userDataUpdates, null, false);\n    // STEP 6: Grant items\n    if (!App.IsNull(fullEnemyGroup.droptable)) {\n        const itemGranted = App.EvaluateRandomResultTable(null, fullEnemyGroup.droptable);\n        App.GrantItemsToUser(currentPlayerId, [itemGranted]);\n        itemsGranted.push(itemGranted);\n    }\n    response.itemsGranted = itemsGranted;\n    App.WritePlayerEvent(currentPlayerId, `combat_finished`, args);\n    return response;\n};\nhandlers.playerLogin = function (args, context) {\n    const response = {\n        playerHP: 0,\n        equipment: {},\n        xp: 0,\n        level: 1,\n        inventory: null\n    };\n    // Get inventory and convert from the server model to the client model (they look identical, except to TypeScript)\n    const inventory = App.GetUserInventory(currentPlayerId);\n    response.inventory = {\n        Inventory: inventory.Inventory,\n        VirtualCurrency: inventory.VirtualCurrency,\n        VirtualCurrencyRechargeTimes: inventory.VirtualCurrencyRechargeTimes\n    };\n    // Give new players some stats using user internal data\n    const userDataRecords = [App.UserData.HP, App.UserData.Equipment, App.UserData.MaxHP];\n    let userData = App.GetUserData(currentPlayerId, userDataRecords);\n    const userInternalData = App.GetUserInternalData(currentPlayerId, userDataRecords);\n    // Hey, I borked this up when I first made this game. User data is writable by the client.\n    // Whoops! Super insecure. Now I have these 15 lines to convert user data to internal data.\n    // Check to see if you are a user whose private stats should be in internal data\n    const isUserDataNull = App.IsNull(userData.Data) || App.IsNull(Object.keys(userData.Data));\n    const isUserDataInternalNull = App.IsNull(userInternalData.Data) || App.IsNull(Object.keys(userInternalData.Data));\n    if (isUserDataNull && isUserDataInternalNull) {\n        // You're an utterly new player. Use internal data.\n    }\n    else if (!isUserDataNull && isUserDataInternalNull) {\n        // You're an old player that hasn't been migrated yet.\n        // Set your internal data with what's new and clear out your regular user data\n        App.UpdateUserInternalData(currentPlayerId, convertUserDataResultToStringDictionary(userData.Data), null, false);\n        App.UpdateUserData(currentPlayerId, null, userDataRecords);\n    }\n    else if (isUserDataNull && !isUserDataInternalNull) {\n        // You've been converted. Swap your user data for the results of the internal data call.\n        userData = userInternalData;\n    }\n    // Done checking for that\n    if (App.IsNull(userData.Data[App.UserData.HP])) {\n        App.UpdateUserInternalData(currentPlayerId, {\n            [App.UserData.HP]: App.Config.StartingHP.toString(),\n            [App.UserData.MaxHP]: App.Config.StartingHP.toString(),\n        }, null, false);\n        response.playerHP = App.Config.StartingHP;\n    }\n    else {\n        response.playerHP = parseInt(userData.Data[App.UserData.HP].Value);\n    }\n    // We also need to know your current XP and level\n    const statistics = App.GetPlayerStatistics(currentPlayerId, [App.Statistics.Level, App.Statistics.XP]);\n    const statisticXP = statistics.find(s => s.StatisticName === App.Statistics.XP);\n    if (!App.IsNull(statisticXP)) {\n        response.xp = statisticXP.Value;\n    }\n    const statisticLevel = statistics.find(s => s.StatisticName === App.Statistics.Level);\n    if (!App.IsNull(statisticLevel)) {\n        response.level = statisticLevel.Value;\n    }\n    // And return any equipment which existing users might have\n    if (!App.IsNull(userData.Data[App.UserData.Equipment])) {\n        response.equipment = JSON.parse(userData.Data[App.UserData.Equipment].Value);\n    }\n    return response;\n};\nhandlers.returnToHomeBase = function (args, context) {\n    const hpAndMaxHP = App.GetUserInternalData(currentPlayerId, [App.UserData.HP, App.UserData.MaxHP]);\n    const maxHP = parseInt(hpAndMaxHP.Data[App.UserData.MaxHP].Value);\n    App.WritePlayerEvent(currentPlayerId, \"travel_to_home_base\", null);\n    if (hpAndMaxHP.Data[App.UserData.HP].Value === hpAndMaxHP.Data[App.UserData.MaxHP].Value) {\n        return {\n            maxHP\n        };\n    }\n    App.UpdateUserInternalData(currentPlayerId, {\n        [App.UserData.HP]: hpAndMaxHP.Data[App.UserData.MaxHP].Value,\n    }, null, false);\n    return {\n        maxHP\n    };\n};\nhandlers.equipItem = function (args, context) {\n    const currentEquipment = App.GetUserInternalData(currentPlayerId, [App.UserData.Equipment]).Data;\n    let returnResult = null;\n    const equipmentDictionary = App.IsNull(args.multiple)\n        ? { [args.single.slot]: args.single.itemInstanceId }\n        : args.multiple.reduce((dictionary, request) => {\n            dictionary[request.slot] = request.itemInstanceId;\n            return dictionary;\n        }, {});\n    if (App.IsNull(currentEquipment[App.UserData.Equipment])) {\n        returnResult = App.UpdateUserInternalData(currentPlayerId, {\n            [App.UserData.Equipment]: JSON.stringify(equipmentDictionary)\n        }, null, true);\n    }\n    else {\n        returnResult = App.UpdateUserInternalData(currentPlayerId, {\n            [App.UserData.Equipment]: JSON.stringify(Object.assign({}, JSON.parse(currentEquipment[App.UserData.Equipment].Value), equipmentDictionary))\n        }, null, true);\n    }\n    App.WritePlayerEvent(currentPlayerId, \"equipped_item\", args);\n    return returnResult;\n};\n// ----- Helpers ----- //\nfunction isKilledEnemyGroupValid(args, planetData, enemyData) {\n    const planet = planetData.find(p => p.name === args.planet);\n    if (planet === undefined) {\n        return `Planet ${args.planet} not found.`;\n    }\n    const area = planet.areas.find(a => a.name === args.area);\n    if (area === undefined) {\n        return `Area ${args.area} not found on planet ${args.planet}.`;\n    }\n    const enemyGroup = area.enemyGroups.find(e => e === args.enemyGroup);\n    if (enemyGroup === undefined) {\n        return `Enemy group ${args.enemyGroup} not found in area ${args.area} on planet ${args.planet}.`;\n    }\n    const fullEnemyGroup = enemyData.enemyGroups.find(e => e.name === args.enemyGroup);\n    if (fullEnemyGroup === undefined) {\n        return `Enemy group ${args.enemyGroup} not found.`;\n    }\n    return undefined;\n}\n;\nfunction levelPlayer(titleDataLevels, yourLevel, yourXP) {\n    let nextLevelNumber = yourLevel + 1;\n    const nextLevel = titleDataLevels.find(l => l.level === nextLevelNumber);\n    if (yourXP >= nextLevel.xp) {\n        return nextLevel;\n    }\n    return null;\n}\nfunction convertUserDataResultToStringDictionary(userData) {\n    if (App.IsNull(userData)) {\n        return {};\n    }\n    return Object.keys(userData).reduce((dictionary, key) => {\n        dictionary[key] = userData[key].Value;\n        return dictionary;\n    }, {});\n}\n"
        }
    ],
    "IsPublished": true
}